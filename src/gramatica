Package compilador;
 
Helpers     
    charmin = ['a' .. 'z']+;
    charmai = ['A' .. 'Z']+;
    char = [['a'..'z'] + ['A'..'Z']];
    digito = ['0' .. '9']+;
    qualquer_char = [0x0 .. 0xffff];
    
    hunderscore = '_';
    hponto = '.';
    
    cr = 13 ;
    lf = 10 ;
    tab = 9 ;
    blank = ' ';
    hchar_ignored = cr|lf|blank|tab|'\n';
    nao_cr_lf = [qualquer_char - [13 + 10]];
    nao_estrela = [qualquer_char - '*'];
    nao_estrela_barra = [nao_estrela - '/'];
    hstring = ''' [nao_cr_lf - ''']+ ''';
 
Tokens
    comment_line = '//' [qualquer_char - 10]* hchar_ignored*;
    coment_bloco = '/*' nao_estrela* '*'+ (nao_estrela_barra nao_estrela* '*'+)* '/';
    
    underscore = hunderscore;
    numero_real = digito? ',' digito+;
    numero_inteiro = digito+;
            
    e = 'e';
    ou = 'ou';
    xor = 'xor';
    nao = 'nao';
    
    mais = '+';
    menos = '-';
    divisao = '/';
    mult = '*';    
    
    menor = '<';
    menor_igual = '<=';
    maior = '>';
    maior_igual = '>=';
    
    seta = '<-';
    igual_igual = '==';
    diferente = '<>';
    igual = '=';    
 
    ponto_e_virgula = ';';
    virgula = ',';
    abre_paren = '(' ;
    fecha_paren = ')' ;
    abre_colchete = '[' ;
    fecha_colchete = ']' ;
    abre_chave = '{' ;
    fecha_chave = '}' ;
    abre_coment = '/*' ;
    fecha_coment = '*/' ;
    ponto = '.';
    dois_pontos = ':';
    
    leia = 'leia';
    escreva = 'escreva';
    programa = 'programa';
    var = 'var';
    se = 'se';
    entao = 'entao';
    senao = 'senao';
    enquanto = 'enquanto';    
    faca = 'faca';
    repita = 'repita';
    ate = 'ate';
    para = 'para';
    de = 'de';
    passo = 'passo';
    inicio = 'inicio';
    fim_ponto = 'fim.';
    fim_se = 'fim' hchar_ignored+ 'se';    
    fim_enquanto = 'fim' hchar_ignored+ 'enquanto';
    fim_para = 'fim para';
    fim = 'fim';
    
    real = 'real';
    inteiro = 'inteiro';
    caractere = 'caractere';
    
    string = hstring;
    
    const = 'const';
    identificador = (hunderscore | char) (char | digito | hunderscore)*;
    char_ignored = hchar_ignored;
    
Ignored Tokens
    char_ignored, comment_line;
    
Productions
    start {-> start}= {start} esqueleto_programa {-> New start(esqueleto_programa)};
    esqueleto_programa {-> esqueleto_programa}= programa identificador ponto_e_virgula declaracao? inicio parte_comandos fim_ponto
    {-> New esqueleto_programa(identificador,[declaracao.parte_declaracao],parte_comandos)};
    
    declaracao {-> parte_declaracao*} = parte_declaracao+ {-> [parte_declaracao]};
    parte_declaracao = {pd} declaracao_variavel {-> declaracao_variavel.parte_declaracao}
    				| {pd2} declaracao_constante {-> declaracao_constante.parte_declaracao};
    declaracao_variavel {-> parte_declaracao} = var tipo dois_pontos id_virgula ponto_e_virgula
    	{-> New parte_declaracao.declaracao_variavel(tipo,id_virgula)};
    declaracao_constante {-> parte_declaracao} = const identificador tipo ponto_e_virgula {-> New parte_declaracao.declaracao_constante(identificador,tipo)};
	
    parte_comandos {-> parte_comandos} = {c1} comandos {-> New parte_comandos.socomando(comandos)}  
    	| {c2} parte_comandos comandos {-> New parte_comandos.outrocomando(parte_comandos,comandos)};
                    
    comandos {-> comandos} = {atribuicao} identificador seta atrib1 ponto_e_virgula {-> New comandos.atribuicao(identificador,seta,atrib1,ponto_e_virgula)}
                    | {leia} leia abre_paren id_virgula fecha_paren ponto_e_virgula {-> New comandos.leia(id_virgula)}
                    | {escreva} escreva abre_paren exp_virgula? expressao fecha_paren ponto_e_virgula {-> New comandos.escreva(escreva,abre_paren,exp_virgula,expressao,fecha_paren,ponto_e_virgula)}
                    | {condicional} condicional {-> New comandos.condicional(condicional)}
                    | {repeticao} repeticao {-> New comandos.repeticao(repeticao)};
    
    condicional {-> condicional} = se abre_paren expressao_logica fecha_paren entao parte_comandos cond_senao fim_se ponto_e_virgula
    {-> New condicional(se,abre_paren,expressao_logica,fecha_paren,entao,parte_comandos,cond_senao,fim_se,ponto_e_virgula)};
    cond_senao {-> cond_senao} = {sub} cond_senao_sub {-> New cond_senao(cond_senao_sub)}
    			| {vazio} {-> New cond_senao(Null)};
    cond_senao_sub {-> cond_senao_sub} = senao parte_comandos {-> New cond_senao_sub(senao,parte_comandos)};
    
    repeticao {-> repeticao} = {enquanto} enquanto abre_paren expressao_logica fecha_paren faca parte_comandos fim_enquanto
    {-> New repeticao.enquanto(enquanto,abre_paren,expressao_logica,fecha_paren,faca,parte_comandos,fim_enquanto)}
            | {repita} repita parte_comandos ate abre_paren expressao_logica fecha_paren ponto_e_virgula
            {-> New repeticao.repita(repita,parte_comandos,ate,abre_paren,expressao_logica,fecha_paren,ponto_e_virgula)}
            | {para} para identificador de numero_inteiro para_sub parte_comandos fim_para ponto_e_virgula
            {-> New repeticao.para(para,identificador,de,numero_inteiro,para_sub,parte_comandos,fim_para,ponto_e_virgula)};
    
    id_virgula {-> id_virgula}= {id} identificador {-> New id_virgula.id(identificador)}
    		| {idv} identificador virgula id_virgula {-> New id_virgula.idvirgula(identificador,id_virgula)};
    		//| {idv} id_virgula identificador virgula {-> New id_virgula.idvirgula(id_virgula,identificador)}; 
    
    exp_virgula {-> exp_virgula} = {exp_virgula} expressao virgula {-> New exp_virgula(expressao,virgula)};
    fim_para_ponto_virgula = {fp_pv} fim_para ponto_e_virgula;
    atrib1 {-> atrib1} = {atrib_id} identificador {-> New atrib1.identificador(identificador)}
    				| {atrib_numi} numero_inteiro {-> New atrib1.numero_inteiro(numero_inteiro)} 
    				| {atrib_numr} numero_real {-> New atrib1.numero_real(numero_real)}
    				| {atrib_str} string {-> New atrib1.string(string)};
    para_sub {-> para_sub} = {p_sub_ate} ate numero_inteiro para_sub_passo {-> New para_sub(ate,numero_inteiro,para_sub_passo)};
    para_sub_passo {-> para_sub_passo} = {p_sub_passo1} passo numero_inteiro para_sub_ate {-> New para_sub_passo.passoate(passo,numero_inteiro,para_sub_ate)} 
    				| {p_sub_passo2} para_sub_ate {-> New para_sub_passo.ate(para_sub_ate)};
    para_sub_ate {-> para_sub_ate} = {p_sub_ate} ate numero_inteiro {-> New para_sub_ate(ate,numero_inteiro)};
    
    valor {-> valor}= {v1} string {-> New valor.string(string)} 
    				| {v2} numero_inteiro {-> New valor.numero_inteiro(numero_inteiro)} 
    				| {v3} numero_real {-> New valor.numero_real(numero_real)};
    variavel {-> variavel}= {v1} identificador {-> New variavel.identificador(identificador)} 
    				| {v2} identificador abre_colchete numero_inteiro fecha_colchete
    				{-> New variavel.vetor(identificador,abre_colchete,numero_inteiro,fecha_colchete)};
     
    tipo {-> tipo} = {real} real {-> New tipo.real(real)}
    				| {int} inteiro {-> New tipo.inteiro(inteiro)}
    				| {char} caractere {-> New tipo.caractere(caractere)};
    soma = {mais} mais | {menos} menos;
    multiplicacao = {mult} mult | {div} divisao;
    op_relacional = {opr1} op_relacional_igual | {opr2} op_relacional_comp; 
	op_relacional_igual {-> op_relacional_igual} = {igual} igual {-> New op_relacional_igual.igual(igual)}
						| {diferente} diferente {-> New op_relacional_igual.diferente(diferente)};
	op_relacional_comp {-> op_relacional_comp} = {menor} menor {-> New op_relacional_comp.menor(menor)} 
					| {menor_igual} menor_igual {-> New op_relacional_comp.menor_igual(menor_igual)}
					| {maior} maior {-> New op_relacional_comp.maior(maior)}
					| {maior_igual} maior_igual {-> New op_relacional_comp.maior_igual(maior_igual)};
    op_logico = {e} e | {ou} ou | {xor} xor;
    op_logico_ou {-> op_logico_ou} = {ou} ou {-> New op_logico_ou.ou(ou)}| {xor} xor {-> New op_logico_ou.xor(xor)};
    
    expressao_geral = {e1} expressao | {e2} expressao_logica;
    
    expressao {-> expressao} = {exp1} expressao mais termo {-> New expressao.mais(expressao,mais,termo)} 
    			| {exp2} expressao menos termo {-> New expressao.menos(expressao,menos,termo)}
    			| {termo} termo {-> New expressao.termo(termo)};
    termo {-> termo} = {term1} termo mult fator {-> New termo.mult(termo,mult,fator)}
    		| {term2} termo divisao fator {-> New termo.divisao(termo,divisao,fator)}
    		| {fator} fator {-> New termo.fator(fator)};
    fator {-> fator} = {fator1} abre_paren expressao fecha_paren {-> New fator.paren(abre_paren,expressao,fecha_paren)}
    		| {valor} valor {-> New fator.valor(valor)} 
    		| {variavel} variavel {-> New fator.variavel(variavel)};
    
    expressao_logica {-> expressao_logica} = {expl1} expressao_logica op_logico_ou termo_log {-> New expressao_logica.op_logico(expressao_logica,op_logico_ou,termo_log)}
    					| {expl2} termo_log {-> New expressao_logica.termo_log(termo_log)};
    termo_log {-> termo_log} = {termol1} termo_log e exp_rel {-> New termo_log.e(termo_log,e,exp_rel)} 
    					| {termol2} exp_rel {-> New termo_log.exp_rel(exp_rel)};
    exp_rel {-> exp_rel} = {expr1} fator_rel op_relacional_igual termo_rel {-> New exp_rel.igual(fator_rel,op_relacional_igual,termo_rel)} 
    					| {expr2} termo_rel {-> New exp_rel.termo_rel(termo_rel)};
    termo_rel {-> termo_rel} = {termor1} termo_rel op_relacional_comp fator_rel {-> New termo_rel.comp(termo_rel,op_relacional_comp,fator_rel)} 
    					| {termor2} fator_rel {-> New termo_rel.fator_rel(fator_rel)};
    fator_rel {-> fator_rel} = {fr1} paren {-> New fator_rel.paren(paren)} 
    					| {fr2} nao paren {-> New fator_rel.naoparen(nao,paren)}
    					| {fr3} valor {-> New fator_rel.valor(valor)} 
    					| {fr4} variavel {-> New fator_rel.variavel(variavel)};
    paren {-> paren} = abre_paren expressao_logica fecha_paren {-> New paren(abre_paren,expressao_logica,fecha_paren)};
    
Abstract Syntax Tree
	start = esqueleto_programa;
	esqueleto_programa = identificador parte_declaracao* parte_comandos;
	
	//declaracao = parte_declaracao+;
	parte_declaracao = {declaracao_variavel} tipo id_virgula
   					| {declaracao_constante} identificador tipo;   					   	
   	
   	tipo = {real} real | {inteiro} inteiro | {caractere} caractere;
	
	parte_comandos  = {socomando} comandos | {outrocomando} parte_comandos comandos;	
	comandos = {atribuicao} identificador seta atrib1 ponto_e_virgula
                    | {leia} id_virgula
                    | {escreva} escreva abre_paren exp_virgula? expressao fecha_paren ponto_e_virgula
                    | {condicional} condicional
                    | {repeticao} repeticao;
                    
	id_virgula = {id} identificador | {idvirgula} identificador id_virgula;
	//id_virgula = {id} identificador | {idvirgula} id_virgula identificador;	
	atrib1 = {identificador} identificador | {numero_inteiro} numero_inteiro | {numero_real} numero_real | {string} string;
	exp_virgula = expressao virgula;
	condicional = se abre_paren expressao_logica fecha_paren entao parte_comandos cond_senao fim_se ponto_e_virgula;
	cond_senao = cond_senao_sub?;
	cond_senao_sub = senao parte_comandos; 
	repeticao  = {enquanto} enquanto abre_paren expressao_logica fecha_paren faca parte_comandos fim_enquanto
            | {repita} repita parte_comandos ate abre_paren expressao_logica fecha_paren ponto_e_virgula
            | {para} para identificador de numero_inteiro para_sub parte_comandos fim_para ponto_e_virgula;

	para_sub = ate numero_inteiro para_sub_passo;
    para_sub_passo = {passoate} passo numero_inteiro para_sub_ate | {ate} para_sub_ate;
    para_sub_ate = ate numero_inteiro;
	
	valor = {string} string | {numero_inteiro} numero_inteiro | {numero_real} numero_real;
	variavel = {identificador} identificador | {vetor} identificador abre_colchete numero_inteiro fecha_colchete;	

    op_relacional_igual = {igual} igual | {diferente} diferente;
    op_logico_ou = {ou} ou | {xor} xor;    
	op_relacional_comp = {menor} menor | {menor_igual} menor_igual | {maior} maior | {maior_igual} maior_igual;
    
    expressao = {mais} expressao mais termo | {menos} expressao menos termo | {termo} termo;
    termo = {mult} termo mult fator | {divisao} termo divisao fator | {fator} fator;
    fator = {paren} abre_paren expressao fecha_paren | {valor} valor | {variavel} variavel;
    
    expressao_logica = {op_logico} expressao_logica op_logico_ou termo_log | {termo_log} termo_log;
    termo_log = {e} termo_log e exp_rel | {exp_rel} exp_rel;    
    exp_rel = {igual} fator_rel op_relacional_igual termo_rel | {termo_rel} termo_rel;
    termo_rel = {comp} termo_rel op_relacional_comp fator_rel | {fator_rel} fator_rel;
    fator_rel = {paren} paren | {naoparen} nao paren | {valor} valor | {variavel} variavel;
    paren = abre_paren expressao_logica fecha_paren;